`ro cache=FALSE, tidy=FALSE, warning=FALSE, comment=NA, message=FALSE, fig.width=6, fig.height=6, cache.path="cost_of_bias/", verbose=TRUE  or`

```{r echo=FALSE, cache=FALSE }
opts_knit$set(upload.fun = socialR::flickr.url)
options(device = function(width = 5, height = 5) {
    pdf(NULL, width = width, height = height)
})
knitcitations::cleanbib()
````



# Calculating the cost of bias  
 * author Carl Boettiger, <cboettig@gmail.com>
 * license: CC0


 * knitr-formatted [source code](https://github.com/cboettig/pdg_control/blob/master/inst/examples/cost_of_bias.Rmd)
 * [Cached data](http://two.ucdavis.edu/cboettig/data/cost_of_bias/)

Implements a numerical version of the SDP described in `r knitcitations::citep("10.1016/j.jeem.2004.11.005")`.  Then compute the optimal solution under different forms of uncertainty and compare the results.  

``` {r setup, echo=FALSE, cache=FALSE}
rm(list=ls())   
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
````


## Model setup 

We will assume a Beverton-Holt state equation / population dynamics function, <span> \( f(x,h) = \frac{A x}{1 + B x} \)</span>

```{r model}
f <- BevHolt
pars <- c(1.5, 0.05)
K <- (pars[1] - 1)/pars[2]
````
with parameters A = `r pars[1]` and B = `r pars[2]`.  The positive stationary root of the model is given by <span>\( \frac{A-1}{B} \)</span>, `r K`.   

```{r profit}
p <- 1
c0 <- 0.01
c1 <- 0
profit <- profit_harvest(price=p, c0 = c0, c1 = c1) 
````

We also assume a profit function of the form <span>\( \Pi = p h - \left( c_0  + c_1 \frac{h}{x} \right) \frac{h}{x} \)</span>, conditioned on <span>\( h > x \)</span> and <span>\(x > 0 \)</span>, with price p = `r p`, c0 = `r c0`, and c1 = `r c1`.  


```{r grid}
x_grid <- seq(0, 2 * K, length = 100)  
h_grid <- x_grid  
````

and solve the problem on a discrete grid of `r length(x_grid)` for stock size and range `r min(x_grid)`, `r max(x_grid)`.  We use the same set of gridpoints for the possible harvest levels. 


## Scenarios 

We calculate the stochastic transition matrix for the probability of going from any state \\(x_t \\) to any other state \\(x_{t+1}\\) the following year, for each possible choice of harvest \\( h_t \\).  This provides a look-up table for the dynamic programming calculations.

### No Uncertainty 

The first scenario considers the completely deterministic case.  

```{r }
sigma_g <- 0.0001    # Noise in population growth
z_g <- function() 1 
z_m <- function() 1 
z_i <- function() 1 
````

```{r }
deterministic_SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g )
````

```{r }
det_opt <- find_dp_optim(deterministic_SDP_Mat, x_grid, h_grid, OptTime=25, xT=0, 
                     profit, delta=0.05, reward=0)
````

We simulate 100 replicates of this system.  We will used a fixed seed so that we can compare these replicates to simulations under different conditions.  (Of course the seed is irrelevant at this stage since this is actually deterministic).  

```{r }
set.seed(42)
sims_one <- lapply(1:100, function(i){
  ForwardSimulate(f, pars, x_grid, h_grid, x0=K, det_opt$D, z_g, z_m, z_i, profit)
})
````
### Growth uncertainty 

```{r }
sigma_g <- 0.15    # Noise in population growth
z_g <- function() rlnorm(1,  0, sigma_g) # mean 1
z_m <- function() 1 
z_i <- function() 1 
````

The next scenario introduces growth uncertainty into the model, <span> \( x_{t+1} = z_g f(x_t) \) </span>, where `z_g` is lognormal with logmean 0 and logsd of `r sigma_g`.  

```{r }
SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g )
````

```{r }
opt <- find_dp_optim(SDP_Mat, x_grid, h_grid, OptTime=25, xT=0, 
                     profit, delta=0.05, reward=0)
````


As before, we simulate 100 replicates using the same random number sequence, now under this case where the noise in growth is intrinsic and is being accounted for by the management.  

```{r}
set.seed(42)
sims_two <- lapply(1:100, function(i){
  ForwardSimulate(f, pars, x_grid, h_grid, x0=K, opt$D, z_g, z_m, z_i, profit)
})
````

### Growth uncertainty & bias  


```{r}
est_pars <- pars
par_var <- .2
````

This time we consider the same optimization under uncertainty as before, but the simulations introduce bias through a random estimate of the growth rate parameter A, drawn from a normal with mean equal to the true value `r pars[1]` and variance `r par_var`.   Since A is a constant multiplier in the growth dynamics, this is equivalent to a random estimate of mean of the noise process `z_g`.  Our estimate of the parameter is drawn from the distribution and then held fixed for that replicate.  Each replicate draws its own value, so average parameter estimate across the replicates should be close to the true value.  _Isn't this equivalent to the standard parameter uncertainty?_

```{r}
bias <- rnorm(100, pars[1], par_var)
set.seed(42)
sims_three <- lapply(1:100, function(i){
  est_pars[1] <- bias[i]
  ForwardSimulate(f, est_pars, x_grid, h_grid, x0=K, opt$D, z_g, z_m, z_i, profit)
})
````

For the record, the biases by index number are:

```{r }
bias
````

## Known bias

The correct baseline comparison against the above scenario, Mike points out to me, still includes the bias, but solves for the optimal solution of that random draw.  This is much slower since it requires solving a new optimum each time, but parallelizes well.   


```{r}
#require(snowfall)
#sfInit(parallel=T, cpu=16)
#sfLibrary(pdgControl)
#sfExportAll()
set.seed(42)
sims_four <- lapply(1:100, function(i){
  est_pars[1] <- bias[i] 
  SDP_Mat <- determine_SDP_matrix(f, est_pars, x_grid, h_grid, sigma_g )
  opt <- find_dp_optim(SDP_Mat, x_grid, h_grid, OptTime=25, xT=0, 
                     profit, delta=0.05, reward=0)
  ForwardSimulate(f, est_pars, x_grid, h_grid, x0=K, opt$D, z_g, z_m, z_i, profit)
})
````



## Summarize and plot the results                                                   


```{r tidy}
sims <- list(known = sims_one, Growth = sims_two, RandomBias = sims_three, KnownBias = sims_four)

dat <- melt(sims, id=names(sims_one[[1]]))  
dt <- data.table(dat)
setnames(dt, c("L2", "L1"), c("reps", "uncertainty")) # names are nice
````

### Plots 

Let's begin by looking at the dynamics of a single replicate. The line shows Reed's S, the level above which the stock should be harvested (where catch should be the difference between stock and S).  To confirm that this policy is being followed, note that harvesting only occurs when the stock is above this line, and harvest is proportional to the amount by which it is above.  Change the replicate `reps==` to see the results from a different replicate.  

``` {r  onerep }
ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, fishstock)) +
  geom_abline(intercept=opt$S, slope = 0) +
  geom_line(aes(time, harvest), col="darkgreen") + 
  facet_wrap(~uncertainty) 
````


This plot summarizes the stock dynamics by visualizing the replicates. Reed's S shown again.

``` {r  fig.cap="the induced dynamics in the stock size over time, for all replicates, by scenario"}
p1 <- ggplot(dt) + geom_abline(intercept=opt$S, slope = 0) 
p1 + geom_line(aes(time, fishstock, group = reps), alpha = 0.1) + facet_wrap(~uncertainty)
````


``` {r fig.cap="The profits made in each time interval of a single replicate, by scenario"}
ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, profit))  + facet_wrap(~uncertainty)

````


``` {r fig.cap="the distribution of profits by scenario"}
profits <-dt[ , sum(profit), by=c("reps", "uncertainty")] 
ggplot(profits) + geom_histogram(aes(V1)) + facet_wrap(~uncertainty)
````

Summary statistics 

``` {r }
profits[, mean(V1), by=uncertainty]
profits[, sd(V1), by=uncertainty]
````


```{r }
save(list="dt", file="bias.rda")
````

Direct comparisons: 

```{r echo=TRUE}
setkey(dt, uncertainty)
cost_of_bias = dt[uncertainty=="KnownBias", sum(profit), by=reps]$V1 - dt[uncertainty=="RandomBias", sum(profit), by=reps]$V1
cost_of_bias
mean(cost_of_bias)
sd(cost_of_bias)
````

# References

``` {r biblio, echo=FALSE, results="asis"}
I(knitcitations::bibliography())
````
