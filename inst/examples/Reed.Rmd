``` {r  echo=FALSE, cache=FALSE}
opts_knit$set(upload.fun = socialR::flickr.url)
opts_chunk$set(cache=FALSE, tidy=FALSE, warning=FALSE, comment=NA, message=FALSE, verbose=TRUE)
````

# Reed Model

 * Author [Carl Boettiger](http://carlboettiger.info), <cboettig@gmail.com>
 * License: [CC0](http://creativecommons.org/publicdomain/zero/1.0/)
 * Description:  Implements a numerical version of the SDP described in `r knitcitations::citet("10.1016/0095-0696(79)90014-7")`.

``` {r  setup, echo=FALSE, cache=FALSE}
# load required libraries
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
rm(list=ls())
````


Chose the state equation / population dynamics function

``` {r }
#f <- RickerAllee
#pars <- c(2, K, 5)
f <- BevHolt
pars <- c(2,4)
K <- (pars[1]-1)/pars[2]

#K <- 100
#pars <- c(1,K)
#f <- function(x,h,p){
#  sapply(x, function(x){
 #   S = max(x - h, 0)
#    p[1] * S * (1 - S/p[2]) + S
#  })
#}

````

We consider a profits from fishing to be a function of harvest `h` and stock size `x`,  

<div> $$ \Pi(x,h) = h - \left( c_0  + c_1 \frac{h}{x} \right) \frac{h}{x}, $$ </div> 


conditioned on h > x and x > 0,

``` {r  profit}
price <- 1
c0 <- 0
c1 <- 0
profit <- profit_harvest(price=price, c0 = c0, c1=c1) 
````

with price = `r price`, `c0` = `r c0` and `c1` = `r c1`. 


``` {r }
xmin <- 0
xmax <- K*1.5
grid_n <- 200
````

We seek a harvest policy which maximizes the discounted profit from the fishery using a stochastic dynamic programming approach over a discrete grid of stock sizes from `r xmin` to `r xmax` on a grid of `r grid_n` points, and over an identical discrete grid of possible harvest values.  


``` {r  grid}
x_grid <- seq(xmin, xmax, length = grid_n)  
h_grid <- x_grid  
````


``` {r miscpars}
delta <- 0.05
xT <- 0
OptTime <- 25
sigma_g <- .1
````

We will determine the optimal solution over a `r OptTime` time step window with boundary condition for stock at `r xT` and discounting rate of `r delta`.  The Reed model considers a stochastic growth model 

<div> $$ x_{t+1} = z_g f(x_t) $$ </div> 

for the random variable `z_g`, given by 

``` {r noise}
#z_g <- function() 1 + rlnorm(1,0, sigma_g)  
pdfn <- function(P, s) dlnorm(P, 0, s)

#z_g <- function() 1+(2*runif(1, 0,  1)-1) * sigma_g
#pdfn <- function(P, s)  dunif(P, 1 - s, 1 + s)
````




``` {r  SDP_Mat}
SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g, pdfn)
````

### Find the optimum by dynamic programming

Bellman's algorithm to compute the optimal solution for all possible trajectories.

``` {r  find_dp_opt }
opt <- find_dp_optim(SDP_Mat, x_grid, h_grid, OptTime, xT, profit, delta, reward=0)
opt$S
````



Stationary optimal policy:  

``` {r value_iteration }
s_opt <- value_iteration(SDP_Mat, x_grid, h_grid, OptTime=1000, xT, profit, delta)
````


## Compare to Clark (noise-free)

``` {r  }
SDP_Mat2 <- determine_SDP_matrix(f, pars, x_grid, h_grid, 0.001, pdfn)
````

Bellman's algorithm to compute the optimal solution for all possible trajectories.

``` {r  find_dp_optdet }
det <- find_dp_optim(SDP_Mat2, x_grid, h_grid, OptTime, xT, profit, delta, reward=0)
````



Note that `SDP_Mat` is specified from the calculation above, as are our grids and our profit function. `OptTime` is the stopping time.  `xT` specifies a boundary condition at the stopping time. A reward for meeting this boundary must be specified for it to make any difference.  `delta` indicates the economic discount rate. Again, details are in the function documentation.   


Plot the policy function (in terms of escapement, `x-h`, rather than harvest `h`) at equilibrium (first time-step):

``` {r policyfn_plot}
require(reshape2)
policies <- melt(data.frame(stock=x_grid, 
                            S = x_grid[opt$D[,1]], 
                            D = x_grid[det$D[,1]], 
                            Stationary = x_grid[s_opt$D]
                            ), id="stock")
q1 <- ggplot(policies, aes(stock, stock - value, color=variable)) + geom_point(alpha=.4) + xlab("stock size") + ylab("escapement") 
q1
````

and the value function (at equilibrium):

``` {r valuefn_plot}
q2 <- qplot(x_grid, opt$V, xlab="stock size", ylab="value") + 
geom_vline(xintercept=opt$S)
q2
````





### Simulate 
Now we'll simulate 100 replicates of this stochastic process under the Reed optimal harvest policy determined above.

No other sources of noise enter into the dynamics.  

``` {r othernoise}
z_m <- function() 1
z_i <- function() 1
````


``` {r  simulate }
sims <- lapply(1:100, function(i){
  ForwardSimulate(f, pars, x_grid, h_grid, x0=K, opt$D, z_g, z_m, z_i)
})
````

The forward simulation algorithm needs an initial condition `x0` which we set equal to the carrying capacity, as well as our population dynamics `f`, parameters `pars`, grids, and noise coefficients.  Recall in the Reed case only `z_g`, growth, is stochastic.  


## Summarize and plot the results                                                   

R makes it easy to work with this big replicate data set.  We make data tidy (melt), fast (data.tables), and nicely labeled.

``` {r  tidy}
dat <- melt(sims, id=names(sims[[1]]))  
dt <- data.table(dat)
setnames(dt, "L1", "reps") # names are nice
````

### Plots 

Let's begin by looking at the dynamics of a single replicate. The line shows Reed's S, the level above which the stock should be harvested (where catch should be the difference between stock and S).  To confirm that this policy is being followed, note that harvesting only occurs when the stock is above this line, and harvest is proportional to the amount by which it is above.  Change the replicate `reps==` to see the results from a different replicate.  

``` {r  p0}
p0 <- ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, fishstock)) +
  geom_abline(intercept=opt$S, slope = 0) +
  geom_line(aes(time, harvest), col="darkgreen") 
p0
````


This plot summarizes the stock dynamics by visualizing the replicates. Reed's S shown again, along with the dotted line showing the allee threshold, below which the stock will go to zero (unless rescued stochastically). 

``` {r  p1}
p1 <- ggplot(dt) + geom_abline(intercept=opt$S, slope = 0) + 
  geom_abline(intercept=xT, slope = 0, lty=2) 
p1 <- p1 + geom_line(aes(time, fishstock, group = reps), alpha = 0.2)
p1
````


# References

``` {r biblio, echo=FALSE, results="asis"}
# knitcitations::bibliography("html")
````



