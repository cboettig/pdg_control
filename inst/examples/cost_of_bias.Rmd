`ro cache=TRUE, tidy=FALSE, warning=FALSE, comment=NA, message=FALSE, fig.width=6, fig.height=6, cache.path="cost_of_bias/", echo=FALSE or`

```{r echo=FALSE, cache=FALSE }
opts_knit$set(upload.fun = socialR::flickr.url)
options(device = function(width = 5, height = 5) {
    pdf(NULL, width = width, height = height)
})
knitcitations::cleanbib()
````



# Calculating the cost of bias  
 * author Carl Boettiger, <cboettig@gmail.com>
 * license: CC0


 * knitr-formatted [source code](https://github.com/cboettig/pdg_control/blob/master/inst/examples/cost_of_bias.Rmd)
 * [Cached data](http://two.ucdavis.edu/cboettig/data/cost_of_bias/)

Implements a numerical version of the SDP described in `r knitcitations::citep("10.1016/j.jeem.2004.11.005")`.  Then compute the optimal solution under different forms of uncertainty and compare the results.  

``` {r setup, echo=FALSE}
rm(list=ls())   
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
rm(list=ls())
````


## Model setup 

We will assume a Beverton-Holt state equation / population dynamics function, <span> \( f(x,h) = \frac{A x}{1 + B x} \)</span>

```{r model}
f <- BevHolt
pars <- c(1.5, 0.05)
K <- (pars[1] - 1)/pars[2]
````
with parameters A = `r pars[1]` and B = `r pars[2]`.  The positive stationary root of the model is given by <span>\( \frac{A-1}{B} \)</span>, `r K`.   

```{r profit}
p <- 1
c0 <- 0.01
c1 <- 0
profit <- profit_harvest(price=p, c0 = c0, c1 = c1) 
````

We also assume a profit function of the form <span>\( \Pi = p h - \left( c_0  + c_1 \frac{h}{x} \right) \frac{h}{x} \)</span>, conditioned on <span>\( h > x \)</span> and <span>\(x > 0 \)</span>, with price p = `r p`, c0 = `r c0`, and c1 = `r c1`.  


```{r grid}
x_grid <- seq(0, 2 * K, length = 100)  
h_grid <- x_grid  
````

and solve the problem on a discrete grid of `r length(x_grid)` for stock size and range `r min(x_grid)`, `r max(x_grid)`.  We use the same set of gridpoints for the possible harvest levels. 


## Scenarios 

We calculate the stochastic transition matrix for the probability of going from any state \\(x_t \\) to any other state \\(x_{t+1}\\) the following year, for each possible choice of harvest \\( h_t \\).  This provides a look-up table for the dynamic programming calculations. In the Sethi case, computing the distribution over multiple sources of noise is actually quite difficult.  Simulation turns out to be more efficient than numerically integrating over each distribution.  We use this matrix to compute the optimum strategy for all possible states of the world by dynamic programming, and then simulate replicates while applying this rule.   


### No Uncertainty 

The first scenario considers the completely deterministic case.  

```{r }
z_g <- function() 1 
z_m <- function() 1 
z_i <- function() 1 
````

```{r }
deterministic_SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g )
````

```{r }
det_opt <- find_dp_optim(deterministic_SDP_Mat, x_grid, h_grid, OptTime=25, xT=0, 
                     profit, delta=0.05, reward=0)
````

We simulate 100 replicates of this system.  We will used a fixed seed so that we can compare these replicates to simulations under different conditions.  (Of course the seed is irrelevant at this stage since this is actually deterministic).  

```{r }
set.seed(42)
sims_one <- lapply(1:100, function(i){
  ForwardSimulate(f, pars, x_grid, h_grid, x0=K, det_opt$D, z_g, z_m, z_i, profit)
})
````
### Growth uncertainty 

```{r }
sigma_g <- 0.15    # Noise in population growth
z_g <- function() rlnorm(1,  0, sigma_g) # mean 1
z_m <- function() 1 
z_i <- function() 1 
````

The next scenario introduces growth uncertainty into the model, <span> \( x_{t+1} = z_g f(x_t) \) </span>, where `z_g` is lognormal with logmean 0 and logsd of `r sigma_g`.  

```{r }
SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g )
````

```{r }
opt <- find_dp_optim(SDP_Mat, x_grid, h_grid, OptTime=25, xT=0, 
                     profit, delta=0.05, reward=0)
````


As before, we simulate 100 replicates using the same random number sequence, now under this case where the noise in growth is intrinsic and is being accounted for by the management.  

```{r}
set.seed(42)
sims_two <- lapply(1:100, function(i){
  ForwardSimulate(f, pars, x_grid, h_grid, x0=K, opt$D, z_g, z_m, z_i, profit)
})
````

### Growth uncertainty & bias  


```{r}
est_pars <- pars
par_var <- .1
````

This time we consider the same optimization under uncertainty as before, but the simulations introduce bias through a random estimate of the growth rate parameter A, drawn from a normal with mean equal to the true value `r pars[1]` and variance `r par_var`.   Since A is a constant multiplier in the growth dynamics, this is equivalent to a random estimate of mean of the noise process `z_g`.  Our estimate of the parameter is drawn from the distribution and then held fixed for that replicate.  Each replicate draws its own value, so average parameter estimate across the replicates should be close to the true value.  _Isn't this equivalent to the standard parameter uncertainty?_

```{r}
set.seed(42)
sims_three <- lapply(1:100, function(i){
  est_pars[1] <- rnorm(1, pars[1], par_var)
  ForwardSimulate(f, est_pars, x_grid, h_grid, x0=K, opt$D, z_g, z_m, z_i, profit)
})
````


## Unbiased error in growth estimate

```{r}
sigma_g <- sqrt(0.15^2 + par_var^2)   # Noise in population growth
z_g <- function() rlnorm(1,  0, sigma_g) # mean 1
z_m <- function() 1 
z_i <- function() 1 
````

We will compare this result to the situation of underestimating the uncertainty in the growth rate, but knowning the parameter exactly.  We use the deterministic optimum solution under a reality that has log-normal growth noise equal to the sum of the variances in the previous example, \( \sigma_g = \)  `r sigma_g`.  


```{r}
set.seed(42)
sims_four <- lapply(1:100, function(i){
  ForwardSimulate(f, pars, x_grid, h_grid, x0=K, det_opt$D, z_g, z_m, z_i, profit)
})
````



## Summarize and plot the results                                                   


```{r tidy}
sims <- list(known = sims_one, Growth = sims_two, Bias = sims_three, Underestimate = sims_four)

dat <- melt(sims, id=names(sims_one[[1]]))  
dt <- data.table(dat)
setnames(dt, c("L2", "L1"), c("reps", "uncertainty")) # names are nice
````

### Plots 

Let's begin by looking at the dynamics of a single replicate. The line shows Reed's S, the level above which the stock should be harvested (where catch should be the difference between stock and S).  To confirm that this policy is being followed, note that harvesting only occurs when the stock is above this line, and harvest is proportional to the amount by which it is above.  Change the replicate `reps==` to see the results from a different replicate.  

``` {r  onerep }
ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, fishstock)) +
  geom_abline(intercept=opt$S, slope = 0) +
  geom_line(aes(time, harvest), col="darkgreen") + 
  facet_wrap(~uncertainty) 
````


This plot summarizes the stock dynamics by visualizing the replicates. Reed's S shown again.

``` {r  fig.cap="the induced dynamics in the stock size over time, for all replicates, by scenario"}
p1 <- ggplot(dt) + geom_abline(intercept=opt$S, slope = 0) 
p1 + geom_line(aes(time, fishstock, group = reps), alpha = 0.1) + facet_wrap(~uncertainty)
````


``` {r fig.cap="The profits made in each time interval of a single replicate, by scenario"}
ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, profit))  + facet_wrap(~uncertainty)

````


``` {r fig.cap="the distribution of profits by scenario"}
profits <-dt[ , sum(profit), by=c("reps", "uncertainty")] 
ggplot(profits) + geom_histogram(aes(V1)) + facet_wrap(~uncertainty)
````

Summary statistics tell the final story:

``` {r }
profits[, mean(V1), by=uncertainty]
profits[, sd(V1), by=uncertainty]
````



# References

``` {r biblio, echo=FALSE, results="asis"}
I(knitcitations::bibliography())
````
