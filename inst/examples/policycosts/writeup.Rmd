


```{r cache-options, include=FALSE}
opts_chunk$set(cache=TRUE, cache.path="writeup/")
```

Define the parameters of our cost function. We will 
consider a fixed price and fixed $c_0$ cost per unit effort.  
An additional "policy cost" is introduced through the $c_2$
coefficient, which can take a range of values. We will loop
over this range for each of the functional forms of the policy
cost, in order to choose coefficients $c_2$ in each case
that are comparable.  


``` {r}
price = 10
c0 = 30
profit <- profit_harvest(price = price, c0 = c0, c1 = 0)
c2 <- exp(seq(0, log(21), length.out = 20))-1
```



Clean the workspace and load the required libraries.

``` {r libraries}
rm(list=ls())
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
```



```{r graphing-options, include=FALSE}
opts_knit$set(upload.fun = socialR::flickr.url)
opts_chunk$set(dev.args=list(bg="transparent"),
               tidy=FALSE, comment=NA, message=FALSE)
theme_notebook <- theme_grey() + 
                  theme(plot.background = 
                          element_rect(fill = "transparent",colour = NA),
                        panel.grid.minor = 
                          element_line(colour = "transparent"))
theme_set(theme_notebook)
```



This block defines the various parameters 
and nuisance parameters we need to specify our
optimal control problem. 


```{r setup}
seed <- 123                 # Random seed (replicable results)
delta <- 0.05               # economic discounting rate
OptTime <- 20               # stopping time
gridsize <- 50              # grid size for fish stock and harvest rate (discretized population)
sigma_g <- 0.2              # Noise in population growth
reward <- 0                 # bonus for satisfying the boundary condition
z_g <- function() rlnorm(1,  0, sigma_g) # mean 1
z_m <- function() 1         # No measurement noise, 
z_i <- function() 1         # No implemenation noise
f <- BevHolt                # Select the state equation
pars <- c(1.5, 0.05)        # parameters for the state equation
K <- (pars[1] - 1)/pars[2]  # Carrying capacity (for reference 
xT <- 0                     # boundary conditions
x0 <- K
x_grid <- seq(0.01, 1.2 * K, length = gridsize)  
h_grid <- seq(0.01, 0.8 * K, length = gridsize)  
````


Given these parameters, we can determine the optimal solution under the classic assumption of "adjustment-free" costs, where there is no penalty for adjusting the value of the control (harvest) at each decision step (year).  


```{r reed, dependson="setup"}
SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g )
opt <- find_dp_optim(SDP_Mat, x_grid, h_grid, OptTime, xT, 
                     profit, delta, reward=reward)
````


Now we introduce the functional forms for each of the adjustment costs,


``` {r fees}
L1 <- function(c2) function(h, h_prev)  c2 * abs(h - h_prev) 
free_increase <- function(c2) function(h, h_prev)  c2 * abs(min(h - h_prev, 0)) # increasing harvest is free
free_decrease <- function(c2) function(h, h_prev)  c2 * max(h - h_prev, 0) # decreasing harvest is free
fixed <-  function(c2) function(h, h_prev) c2 * as.numeric( !(h == h_prev) )
L2 <- function(c2) function(h, h_prev)  c2 * (h - h_prev) ^ 2
none <- function(h, h_prev)  0
penaltyfns <- list(L2=L2, L1=L1, free_decrease=free_decrease, fixed=fixed, free_increase=free_increase)
````


## Apples to Apples levels

Before we can start comparing solutions induced
under each of these costs, we need to scale them
appropriately (e.g. the coefficient $c_2$ has 
different units and a different magnitude of 
effect when multiplied by quadratic differences
$(h_{t} - h_{t-1})^2$ then when multiplied by 
linear differences $h_{t} - h_{t-1}$.  


To do so we loop over a grid of $c_2$ values and
determine the net present value under each functional 
form of adjustment costs for each $c_2$ in our grid.  


``` {r  parallel}
require(snowfall)
sfInit(cpu=2, parallel=T)
sfLibrary(pdgControl)
sfExportAll()
````


### Loop over penalty functions and magnitudes

``` {r  bigloop, dependson=c("setup", "reed", "fees")}
policies <- lapply(penaltyfns, function(penalty){
  sfLapply(c2, function(c2){
      policy <- optim_policy(SDP_Mat, x_grid, h_grid, OptTime, xT, 
                   profit, delta, reward, penalty = penalty(c2))
      }
  )
})
````

Note that `optim_policy` has been updated to return the equilibrium value of profits from fish harvests before the adjustment costs have been paid, `penalty_free_V`.  This contains the values for all possible states, we simply evaluate it at the carrying capacity (which is our initial condition.)  The index in `x_grid` that corresponds to the carrying capacity (initial condition) `i` indicates this.  


We also do the the classical quadratic costs on fishing effort separately,

``` {r  quadcosts, dependson="bigloop"}
quad <- 
  sfLapply(c2, function(c2){
  effort_penalty = function(x,h) (c2 * h / x) / price
  policycost <- optim_policy(SDP_Mat, x_grid, h_grid, OptTime, xT, 
                        profit, delta, reward, penalty = none, 
                        effort_penalty)
})
policies <- c(policies, quad=list(quad))
````


Extract the policy cost

```{r}
i <- which(x_grid > K)[1]
fees <- 
lapply(policies, function(penalty) 
  sapply(penalty, function(c2_run)
    max(c2_run$penalty_free_V[i,]) 
  )
)
```


Tidy up the data and plot the net present value (before the penalty has been paid) relative to that achieved when managed without a penalty.  

``` {r npv-plot, dependson="quadcosts"}
npv0 <- max(fees$L1) # all have same max, at c2=0 
npv0
fees <- data.frame(c2=c2,fees)
fees <- melt(fees, id="c2")
ggplot(fees, aes(c2, value, col=variable)) + geom_point() + geom_line()
````

Find the value of `c2` that brings each penalty closest to 75% of the cost-free adjustment value:

```{r apples_plot, dependson="quadcosts"}
ggplot(fees, aes(c2, (npv0-value)/npv0, col=variable)) + geom_point() + geom_line()
````







```{r apples, dependson="quadcosts"}
closest <- function(x, v){
  which.min(abs(v-x))
}
dt_npv <- data.table(fees)
index <- dt_npv[,closest(0.25, (npv0-value)/npv0), by=variable]
apples_index <- index$V1
names(apples_index) = index$variable
apples <- c2[index$V1]
names(apples) = index$variable
apples
````

Solve the policy cost for the specified penalty function

``` {r policynames}
L2_policy <- policies$L2[[apples_index["L2"]]]$D
L1_policy <- policies$L1[[apples_index["L1"]]]$D
fixed_policy <- policies$fixed[[apples_index["fixed"]]]$D
free_increase_policy <- policies$free_increase[[apples_index["free_increase"]]]$D
free_decrease_policy <- policies$free_decrease[[apples_index["free_decrease"]]]$D
quad_policy <- policies$quad[[apples_index["quad"]]]$D
```

``` {r simulate_policy, dependson="policynames"}
quad_profit <- profit_harvest(price = price, c0 = c0, c1 = apples["quad"]) 
sims <- list(
  L1 = simulate_optim(f, pars, x_grid, h_grid, x0, 
                      L1_policy, z_g, z_m, z_i, 
                      opt$D, profit=profit, penalty=L1(apples["L1"]), seed=seed), 
  L2 = simulate_optim(f, pars, x_grid, h_grid, x0, 
                      L2_policy, z_g, z_m, z_i, 
                      opt$D, profit=profit, penalty=L2(apples["L2"]), seed=seed),
  fixed = simulate_optim(f, pars, x_grid, h_grid, x0, 
                         fixed_policy, z_g, z_m, z_i, 
                         opt$D, profit=profit, penalty=fixed(apples["fixed"]), seed=seed),
  increase = simulate_optim(f, pars, x_grid, h_grid, x0, 
                            free_increase_policy, z_g, z_m, z_i, 
                            opt$D, profit=profit, penalty= free_increase(apples["increase"]), seed=seed),
  decrease = simulate_optim(f, pars, x_grid, h_grid, x0, 
                            free_decrease_policy, z_g, z_m, z_i, 
                            opt$D, profit=profit, penalty= free_decrease(apples["decrease"]), seed=seed),
  quad = simulate_optim(f, pars, x_grid, h_grid, x0, 
                            quad_policy, z_g, z_m, z_i, 
                            opt$D, profit=quad_profit, penalty= none, seed=seed)
)
````


``` {r tidy, dependson="simulate_policy"}
#Make data tidy (melt), fast (data.tables), and nicely labeled.
dat <- melt(sims, id=names(sims[[1]]))  
dt <- data.table(dat)
setnames(dt, "L1", "penalty_fn") # names are nice
````



```{r}
v <- dt[,var(harvest), by="penalty_fn"]
var <- v$V1
names(var) <- v$penalty_fn
acor <- dt[,acf(harvest, plot=F)$acf[2], by="penalty_fn"]$V1
names(acor) <- names(var)
out <- rbind(var=var, a=acor)
out
```





# Plots 


```{r p1, dependson="tidy", fig.width=12}
p1 <- ggplot(dt) +
  geom_line(aes(time, alternate), col="grey20", lwd=1) +
  geom_line(aes(time, fishstock), col=rgb(0,0,1,.8)) + facet_wrap(~penalty_fn) + 
  labs(x="time", y="stock size", title = "Stock Dynamics")
p1
```

```{r Figure3, dependson="tidy", fig.width=12}
p2 <- ggplot(dt) +
  geom_line(aes(time, harvest_alt), col="grey20", lwd=1)  +
  geom_line(aes(time, harvest), col=rgb(0,0,1,.8)) + 
  facet_wrap(~penalty_fn) + 
  labs(x="time", y="havest intensity (fish taken)", title = "Harvest Policy Dynamics")
p2
````

# Figure 4

```{r}
frac_lost <- seq(0,1, length=20)
```

```{r helper_fn_1}
fig4 <- function(fraction_lost){
closest <- function(x, v){
  which.min(abs(v-x))
}
dt_npv <- data.table(fees)
index <- dt_npv[,closest(fraction_lost, (npv0-value)/npv0), by=variable]
apples_index <- index$V1
names(apples_index) = index$variable
apples <- c2[index$V1]
names(apples) = index$variable

L2_policy <- policies$L2[[apples_index["L2"]]]$D
L1_policy <- policies$L1[[apples_index["L1"]]]$D
fixed_policy <- policies$fixed[[apples_index["fixed"]]]$D
free_increase_policy <- policies$free_increase[[apples_index["free_increase"]]]$D
free_decrease_policy <- policies$free_decrease[[apples_index["free_decrease"]]]$D
quad_policy <- policies$quad[[apples_index["quad"]]]$D

quad_profit <- profit_harvest(price = price, c0 = c0, c1 = apples["quad"]) 
sims <- lapply(1:50, function(reps) list(
  L1 = simulate_optim(f, pars, x_grid, h_grid, x0, 
                      L1_policy, z_g, z_m, z_i, 
                      opt$D, profit=profit, penalty=L1(apples["L1"])), 
  L2 = simulate_optim(f, pars, x_grid, h_grid, x0, 
                      L2_policy, z_g, z_m, z_i, 
                      opt$D, profit=profit, penalty=L2(apples["L2"])),
  fixed = simulate_optim(f, pars, x_grid, h_grid, x0, 
                         fixed_policy, z_g, z_m, z_i, 
                         opt$D, profit=profit, penalty=fixed(apples["fixed"])),
  increase = simulate_optim(f, pars, x_grid, h_grid, x0, 
                            free_increase_policy, z_g, z_m, z_i, 
                            opt$D, profit=profit, penalty= free_increase(apples["increase"])),
  decrease = simulate_optim(f, pars, x_grid, h_grid, x0, 
                            free_decrease_policy, z_g, z_m, z_i, 
                            opt$D, profit=profit, penalty= free_decrease(apples["decrease"])),
  quad = simulate_optim(f, pars, x_grid, h_grid, x0, 
                            quad_policy, z_g, z_m, z_i, 
                            opt$D, profit=quad_profit, penalty= none)
  ))

  #Make data tidy (melt), fast (data.tables), and nicely labeled.
  dat <- melt(sims, id=names(sims[[1]][[1]]))  
  dt <- data.table(dat)
  setnames(dt, "L1", "reps") # names are nice
  setnames(dt, "L2", "penalty_fn") # names are nice

  dt
}
```


```{r helper_fn_2} 
# Helper functions to extract the summary stats in different variables
stats_harvest <- function(dt){
v <- dt[,var(harvest), by=c("penalty_fn", "reps")]
acor <- dt[,acf(harvest, plot=F)$acf[2], by=c("penalty_fn", "reps")]
df <- cbind(v, acor$V1)
setnames(df, c("V1", "V2"), c("var", "acor")) # names are nice
df
}

stats_fishstock <- function(dt){
v <- dt[,var(fishstock), by=c("penalty_fn", "reps")]
acor <- dt[,acf(fishstock, plot=F)$acf[2], by=c("penalty_fn", "reps")]
df <- cbind(v, acor$V1)
setnames(df, c("V1", "V2"), c("var", "acor")) # names are nice
df
}
```


```{r helper_fn_3}
#' a simple function for reorganizing the data over the different "faction-lost" levels
get_trends <- function(tmp2){
  out <- melt(tmp2, id=c("reps", "var", "acor"))
  colnames(out) = c("reps", "var", "acor", "nothing", "penalty", "index")
  out <- cbind(out[c(1,2,3,5)], fraction = frac_lost[out$index])
  out <- data.table(out)
  Ev = out[,mean(var),by=c('penalty', 'fraction')]
  SDv = out[,sd(var),by=c('penalty', 'fraction')]
  Ea = out[,mean(acor),by=c('penalty', 'fraction')]
  SDa = out[,sd(acor),by=c('penalty', 'fraction')]
  harvest_trends <- data.table(penalty = Ev$penalty, 
                               fraction = Ev$fraction, 
                               Ev = Ev$V1, Ea = Ea$V1, 
                               SDv=SDv$V1, SDa = SDa$V1)
}
```




```{r Figure4_harvest}
sims_at_each_apple <- lapply(frac_lost, fig4)
harvest_stats <- lapply(sims_at_each_apple, stats_harvest)
harvest_trends <- get_trends(harvest_stats)
```

```{r Figure4}
Fig4a <- ggplot(harvest_trends, 
                aes(fraction, Ev, ymin=Ev-SDv, ymax=Ev+SDv, col=penalty)) + 
  geom_ribbon(aes(fill=penalty, col=NA), lwd=0, alpha=.05) + 
  geom_line() + xlab("Fraction of NPV lost to costs")

Fig4b <- ggplot(harvest_trends, 
                aes(fraction, Ea, ymin=Ea-SDa, ymax=Ea+SDa, col=penalty)) + 
  geom_ribbon(aes(fill=penalty, col=NA), lwd=0, alpha=.05) + 
  geom_line() + xlab("Fraction of NPV lost to costs")
Fig4a
Fig4b
````


```{r Figure4S}
fishstock_stats <- lapply(sims_at_each_apple, stats_fishstock)
fishstock_trends <- get_trends(fishstock_stats)

FigS4a <- ggplot(fishstock_trends, 
                aes(fraction, Ev, ymin=Ev-SDv, ymax=Ev+SDv, col=penalty)) + 
  geom_ribbon(aes(fill=penalty, col=NA), lwd=0, alpha=.05) + 
  geom_line() + xlab("Fraction of NPV lost to costs")

FigS4b <- ggplot(fishstock_trends, 
                aes(fraction, Ea, ymin=Ea-SDa, ymax=Ea+SDa, col=penalty)) + 
  geom_ribbon(aes(fill=penalty, col=NA), lwd=0, alpha=.05) + 
  geom_line() + xlab("Fraction of NPV lost to costs")
FigS4a
FigS4b
```











