`ro cache=FALSE, warning=FALSE, comment=NA, message=FALSE, cache.path="bias_table_measurement/", verbose=TRUE or`

``` {r  echo=FALSE, cache=FALSE }
opts_knit$set(upload.fun = socialR::flickr.url)
options(device = function(width = 5, height = 5) {
    pdf(NULL, width = width, height = height)
})
````



# Calculating the bias table 


``` {r  setup, echo=FALSE, cache=FALSE}
# load required libraries
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
rm(list=ls())
````

Chose the state equation / population dynamics function

``` {r }
f <- function(x,h,p){
  sapply(x, function(x){
  	S = max(x - h, 0)
  	p[1] * S * (1 - S/p[2]) + S
  })
}
````

With `K` = `r K <- 100`, and variable choice of r.  


We consider a profits from fishing to be a function of harvest `h` and stock size `x`,  \\( \Pi(x,h) = h - \left( c_0  + c_1 \frac{h}{x} \right) \frac{h}{x} \\), conditioned on \\( h > x \\) and \\(x > 0 \\),

``` {r  profit}
price <- 1
c0 <- 0.0
c1 <- 0
profit <- profit_harvest(price=price, c0 = c0, c1=c1) 
````

with price = `r price`, `c0` = `r c0` and `c1` = `r c1`. 


``` {r }
xmin <- 0
xmax <- 2.5 * K
grid_n <- 300
````

We seek a harvest policy which maximizes the discounted profit from the fishery using a stochastic dynamic programming approach over a discrete grid of stock sizes from `r xmin` to `r xmax` on a grid of `r grid_n` points, and over an identical discrete grid of possible harvest values.  


``` {r  grid}
x_grid <- seq(xmin, xmax, length = grid_n)  
h_grid <- x_grid  
````


``` {r miscpars}
delta <- 0.05
xT <- 0
OptTime <- 25
sigma_g <- .01
sigma_m <- .5
````

We will determine the optimal solution over a `r OptTime` time step window with boundary condition for stock at `r xT` and discounting rate of `r delta`.  The Reed model considers a stochastic growth model 

<div> $$ x_{t+1} = z_g f(x_t) $$ </div> 

for the random variable `z_g`, given by 

``` {r noise}
z_g <- function() 1+(2*runif(1, 0,  1)-1) * sigma_g
z_m <- function() 1+(2*runif(1, 0,  1)-1) * sigma_m
````

No other sources of noise enter into the dynamics.  

``` {r othernoise}
z_i <- function() 1
````







## Scenario 1: low r

With parameter `r` = `r r <- 1`

``` {r }
pars1 <- c(r, K)
````

``` {r  parallel, cache=FALSE}
require(snowfall) 
sfInit(parallel=TRUE, cpu=16)
````

``` {r sdp_mat}
SDP_Mat1 <- SDP_by_simulation(f, pars1, x_grid, h_grid, z_g, z_m, z_i, reps=1e4)
````

``` {r  }
opt_low <- find_dp_optim(SDP_Mat1, x_grid, h_grid, OptTime, xT, profit, delta, reward=0)
````


## Scenario 2: medium r

With parameter `r` = `r r <- 1.5` 

``` {r }
pars2 <- c(r, K)
````


``` {r sdp_mat2}
SDP_Mat2 <- SDP_by_simulation(f, pars2, x_grid, h_grid, z_g, z_m, z_i, reps=1e4)
````


``` {r  }
opt_med <- find_dp_optim(SDP_Mat2, x_grid, h_grid, OptTime, xT, profit, delta, reward=0)
````

## Scenario 3: high r


With parameter `r` = `r r <- 2` 

``` {r }
pars3 <- c(r, K)
````

``` {r sdp_mat3}
SDP_Mat3 <- SDP_by_simulation(f, pars3, x_grid, h_grid, z_g, z_m, z_i, reps=1e4)
````

``` {r  }
opt_high <- find_dp_optim(SDP_Mat3, x_grid, h_grid, OptTime, xT, profit, delta, reward=0)
````


### plots

``` {r sethiplots, rerun=TRUE}
require(reshape2)
policy <- melt(data.frame(stock = x_grid, 
                          low = opt_low$D[,1],
                          med = opt_med$D[,1],
                          high = opt_high$D[,1]),
               id = "stock")

ggplot(policy) + 
  geom_point(aes(stock, stock-x_grid[value], color=variable), shape='+') +
	stat_smooth(aes(stock, stock-x_grid[value], color=variable), 
    degree=1, se=FALSE, span=0.3) +
  ylab("escapement") 

ggplot(policy) +
  geom_point(aes(stock, x_grid[value], color=variable), shape='+') +
	stat_smooth(aes(stock, x_grid[value], color=variable),
    degree=1, se=FALSE, span=0.3) +
  ylab("harvest") 


value <- melt(data.frame(stock = x_grid, 
                         low=opt_low$V,
                         med=opt_med$V,
                         high=opt_high$V),
              id = "stock")

ggplot(value) + 
  geom_point(aes(stock, value, color=variable), shape='+') +
#  stat_smooth(aes(stock, value, color=variable),
#    degree=0, se=FALSE, span=0.15) +
  ylab("Net Present Value")
````



## Simulations

``` {r simfn, rerun=TRUE} 
simulatereps <- function(opt, pars){
  sims <- lapply(1:5000, function(i){
    ForwardSimulate(f, pars, x_grid, h_grid, x0 = K, opt$D, z_g, z_m, z_i, profit)
  })
  sims
}
````


All cases

``` {r runallsims, dependson="simfn"} 
policyfn <- list(low=opt_low, med=opt_med, high=opt_high)
par_list <- list(pars1, pars2, pars3) 

allcases <- lapply(policyfn, function(policyfn_i){
  lapply(par_list, function(par){
    simulatereps(policyfn_i, par)
  })
})
````

``` {r tidyall, dependson="runallsims"}
sims <- unlist(allcases, recursive=FALSE)
dat <- melt(sims, id=names(sims[[1]][[1]]))  
dt <- data.table(dat)
setnames(dt, c("L2", "L1"), c("reps", "parameter")) # names are nice
````


### Plots 


``` {r  onerep, dependson="tidyall"}
ggplot(subset(dt,reps==1)) +
  geom_line(aes(time, fishstock)) +
  geom_line(aes(time, harvest), col="darkgreen") + 
  facet_wrap(~parameter) 
````

This plot summarizes the stock dynamics by visualizing the replicates.

``` {r stock, fig.cap="the induced dynamics in the stock size over time, for all replicates, by scenario", dependson="tidyall"}
p1 <- ggplot(subset(dt, fishstock>0)) 
p1 + geom_line(aes(time, fishstock, group = reps), alpha = 0.1) + facet_wrap(~parameter)
````


``` {r profits, fig.cap="the distribution of profits by scenario", dependson="tidyall"}
profits <-dt[ , sum(profit), by=c("reps", "parameter")] 
ggplot(profits) + geom_histogram(aes(V1)) + facet_wrap(~parameter)
````

Summary statistics 

``` {r summarystats, cache=FALSE}
means <- profits[, mean(V1), by=parameter]
sds <- profits[, sd(V1), by=parameter]
````

``` {r prettytable, cache=FALSE, results="asis"}
require(xtable)
scenarios <- c("low", "med", "high")
print(xtable(matrix(means$V1, nrow=length(scenarios), dimnames=list(scenarios, scenarios))), type="html")
print(xtable(matrix(sds$V1, nrow=length(scenarios), dimnames=list(scenarios, scenarios))), type="html")
````

``` {r printvalue}
k <- which.min(abs(K-x_grid))
data.frame(low=opt_low$V[k], med=opt_med$V[k], high=opt_high$V[k])
```



