`ro tidy=FALSE, warning=FALSE, comment=NA, message=FALSE, verbose=TRUE, cache=TRUE, cache.path="cautious/" or`

``` {r  echo=FALSE, cache=FALSE}
opts_knit$set(upload.fun = socialR::flickr.url)
options(device = function(width = 5, height = 5) {
    pdf(NULL, width = width, height = height)
})
````

# Critical transition 

 * Author [Carl Boettiger](http://carlboettiger.info), <cboettig@gmail.com>
 * License: [CC0](http://creativecommons.org/publicdomain/zero/1.0/)

``` {r  setup, echo=FALSE, cache=FALSE}
# load required libraries
require(pdgControl)
require(reshape2)
require(ggplot2)
require(data.table)
rm(list=ls())
````


Chose the state equation / population dynamics function

``` {r stateeqn}
f <- May
````

With parameters 

``` {r pars}
pars <- c(r = .75, k = 10, a=1, H=1, Q = 3)
K <- 8 # approx
````

Ask R to show us how this function is defined, and plot the transition point using these parameters.

``` {r showMay, fig.keep="last"}
May

curve(.75*(1-x/10), 0, 10)
curve(1*x^2/(x^3+1), 0, 10, add=T, col="blue")
curve(1.9*x^2/(x^3+1), 0, 10, add=T, col="red")
````





We consider a profits from fishing to be a function of harvest `h` and stock size `x`,  

<div> $$ \Pi(x,h) = h - \left( c_0  + c_1 \frac{h}{x} \right) \frac{h}{x}, $$ </div> 

conditioned on h > x and x > 0,

``` {r  profit}
price <- 1
c0 <- 0.0
c1 <- 0
profit <- profit_harvest(price=price, c0 = c0, c1=c1) 
````

with price = `r price`, `c0` = `r c0` and `c1` = `r c1`. 


``` {r gridpars}
xmin <- 0
xmax <- 1.5 * K
grid_n <- 100
````

We seek a harvest policy which maximizes the discounted profit from the fishery using a stochastic dynamic programming approach over a discrete grid of stock sizes from `r xmin` to `r xmax` on a grid of `r grid_n` points, and over an identical discrete grid of possible harvest values.  


``` {r  grid, dependson="gridpars"}
x_grid <- seq(xmin, xmax, length = grid_n)  
h_grid <- x_grid  
````


``` {r miscpars, dependson="grid"}
delta <- 0.05
xT <- 0
OptTime <- 25
sigma_g <- .2
P <- .5
````

We will determine the optimal solution over a `r OptTime` time step window with boundary condition for stock at `r xT` and discounting rate of `r delta`.  The Reed model considers a stochastic growth model 

<div> $$ x_{t+1} = z_g f(x_t) $$ </div> 

for the random variable `z_g`, given by 

``` {r noise}
z_g <- function() rlnorm(1, 0, sigma_g)
````

No other sources of noise enter into the dynamics.  

``` {r othernoise}
z_m <- function() 1
z_i <- function() 1
````



``` {r  SDP_Mat, dependson="miscpars"}
SDP_Mat <- determine_SDP_matrix(f, pars, x_grid, h_grid, sigma_g)
````


### Find the optimum by dynamic programming


``` {r beparallel, cache=FALSE}
require(snowfall)
sfInit(parallel=TRUE, cpu=2)
````

Bellman's algorithm to compute the a cautious solution that selects a fraction `P` = `P` of the optimal harvest solution for all possible trajectories in the iterative optimization. Loop over 10 values of P.   

``` {r  find_dp_opt, dependson="SDP_Mat"}
P <- seq(0, 1, length.out=10)
opts <- lapply(P, function(P) 
  find_dp_cautious(SDP_Mat, x_grid, h_grid, OptTime, xT, 
                     profit, delta, reward=0, P = P))
````

Note that `SDP_Mat` is specified from the calculation above, as are our grids and our profit function. `OptTime` is the stopping time.  `xT` specifies a boundary condition at the stopping time. A reward for meeting this boundary must be specified for it to make any difference.  `delta` indicates the economic discount rate. Again, details are in the function documentation.   


Plot the policy function (in terms of escapement, `x-h`, rather than harvest `h`) at equilibrium (first time-step):

``` {r policyfn_plot, dependson="find_dp_opt"}
require(reshape2)
dat <- sapply(opts, function(x) x$D[,1])
dat <- as.data.frame(cbind(stock=x_grid, dat))
names(dat) <- c("stock", as.character(round(P,2)))
policy <- melt(dat, id="stock")
ggplot(policy) + geom_line(aes(stock,x_grid - x_grid[value], color=variable)) + ylab("escapement")
````

``` {r valuefn_plot, dependson="find_dp_opt"}
dat <- sapply(opts, function(x) x$V)
dat <- as.data.frame(cbind(stock=x_grid, dat))
names(dat) <- c("stock", as.character(round(P,2)))
policy <- melt(dat, id="stock")
ggplot(policy) + geom_line(aes(stock, value, color=variable)) + ylab("Net present value")

x0_i <- which.min(abs(x_grid-K))
values <- sapply(opts, function(x) x$V[x0_i])
names(values) <- as.character(round(P,2))
values
````


